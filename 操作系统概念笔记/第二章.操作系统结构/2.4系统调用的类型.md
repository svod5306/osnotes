## 2.1系统调用的类型

六大类型，书上说的不再赘述

### 2.4.1进程控制

先吐槽一下这本书的翻译，已经第九版了，有些地方的翻译还是那么的古怪，比如running program：翻译成”正在运行的程序“多好，非要翻译成“执行程序”，比如下面的话猛一看让人觉得费解，啥意思（至少我一开始是懵圈了）。

“执行程序应能正常或异常停止执行”？是操作系统运行一个程序，系统正常执行它或者异常停止它？

在比如后面有一个翻译“域”，根据上下文理解，应该是字段的意思吧。

当程序发生异常，系统应该能生成错误信息，并且把错误信息转储到硬盘文件中，供开发者分析调试。

以前的windows系统不稳定，经常因为某些错误出现蓝屏，这时候下面就会出现一大堆错误信息，并且提示错误信息dump（转储）到什么文件里面。

无论是正常还是异常，系统都应该把控制权收归内核，如果是在shell窗口运行程序，控制权转到shell程序（书上说的是调用命令解释程序，我的理解就是转到shell，不知道对不对），如果是图形用户界面，弹出窗口提示用户出错（这个较为常见）。

一个进程或者批处理的作业可能需要加载另外一个程序，这是就有两种情况：

1）如果进程A或者作业A运行程序B，并且等待程序B完成。这种情况很常见。这时候就是把程序B的进程调入CPU运行，进程A暂时从CPU中退出，这时候就必须保存进程A的上下文数据。

2）如果进程A和被调用的进程B并发继续，这时候相当于多道程序执行，个人认为需要分两种情况，对于单处理器系统，因为多个进程按照时间片轮换执行，程序A的进程上下文必然也需要保存，如果是多处理器系统，则不必保存，在其他处理器上运行进程B即可。

P66页：“如果是创建一个新的进程或者作业”，根据上下文的意思是：如果运行程序B是创建了一个新的进程。但是第一种情况难道不是创建了一个新的进程吗？或者说第一种情况中，程序B的运行是在进程A的内存空间，实际上不存在进程B？（看了P67～68的内容，MSDOS确实没有创建进程，忘了这个老古董了）

同样是P67~68，介绍FreeBSD的外壳通过命令行运行程序的时候，说到了fork()函数，fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，子进程调用exec函数，exec函数提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。

### 2.4.2文件管理

就是要提供和文件、目录有关的一系列功能和接口

### 2.4.3设备管理

操作系统对于设备的访问和文件访问差不多，也是：请求、使用、释放三个步骤。

书上说文件各种资源看作设备，文件是抽象或虚拟的设备。

在linux系统中，甚至一切皆文件，对设备的访问也是通过文件来进行，这些设备的文件放在/dev/目录下，这些文件是设备驱动的接口文件。以前linux系统要使用u盘，要mount /dev/sda1 这个设备,映射到某一个目录，比如

```
mount /dev/sda1 /home/cainiao/upan
```

然后对这个目录的读写就是对优盘的读写。

不用的时候umount /dev/sda1  相当于close()

### 2.4.4信息维护

这一节我看了半天还是觉得不知所云，不知道作者所说的信息维护，是要维护什么信息。仅仅最后一段说了一点。

可能作者的意思是操作系统要维护一些系统信息并在必要的时候为用户进程提供：比如当前时间（第一段）、系统出错后的内存信息，并且dump到文件、进程信息等。是这个意思吗？

第三段的程序时间线，没有听说过，百度到的唯一接近的命令是time命令，这个命令可以运行一个程序，并显示程序的运行时间，包括用户态时间和内核态时间。但是程序启动后，time命令就结束了。

### 2.4.5通信

进程通信常用模型有两个：共享内存和消息传递。






