## 2.1系统调用的类型

六大类型，书上说的不再赘述

### 2.4.1进程控制

先吐槽一下这本书的翻译，已经第九版了，有些地方的翻译还是那么的古怪，比如running program：翻译成”正在运行的程序“多好，非要翻译成“执行程序”，比如下面的话猛一看让人觉得费解，啥意思（至少我一开始是懵圈了）。

“执行程序应能正常或异常停止执行”？是操作系统运行一个程序，系统正常执行它或者异常停止它？

在比如后面有一个翻译“域”，根据上下文理解，应该是字段的意思吧。

当程序发生异常，系统应该能生成错误信息，并且把错误信息转储到硬盘文件中，供开发者分析调试。

以前的windows系统不稳定，经常因为某些错误出现蓝屏，这时候下面就会出现一大堆错误信息，并且提示错误信息dump（转储）到什么文件里面。

无论是正常还是异常，系统都应该把控制权收归内核，如果是在shell窗口运行程序，控制权转到shell程序（书上说的是调用命令解释程序，我的理解就是转到shell，不知道对不对），如果是图形用户界面，弹出窗口提示用户出错（这个较为常见）。

一个进程或者批处理的作业可能需要加载另外一个程序，这是就有两种情况：

1）如果进程A或者作业A运行程序B，并且等待程序B完成。这种情况很常见。这时候就是把程序B的进程调入CPU运行，进程A暂时从CPU中退出，这时候就必须保存进程A的状态数据。

2）如果进程A和被调用的进程B并发继续，这时候相当于多道程序执行，个人认为需要分两种情况，对于单处理器系统，因为多个进程按照时间片轮换执行，程序A的进程状态必然也需要保存，如果是多处理器系统，则不必保存，在其他处理器上运行进程B即可。

P66页：“如果是创建一个新的进程或者作业”，根据上下文的意思是：如果运行程序B是创建了一个新的进程。但是第一种情况难道不是创建了一个新的进程吗？或者说第一种情况中，程序B的运行是在进程A的内存空间，实际上不存在进程B？（看了P67～68的内容，MSDOS确实没有创建进程，忘了这个老古董了）

同样是P67~68，介绍FreeBSD的外壳通过命令行运行程序的时候，说到了fork()函数，fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，子进程调用exec函数，exec函数提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。

### 2.4.2文件管理

就是要提供和文件、目录有关的一系列功能和接口

### 2.4.3设备管理

操作系统对于设备的访问和文件访问差不多，也是：请求、使用、释放三个步骤。

书上说文件各种资源看作设备，文件是抽象或虚拟的设备。

在linux系统中，甚至一切皆文件，对设备的访问也是通过文件来进行，这些设备的文件放在/dev/目录下，这些文件是设备驱动的接口文件。以前linux系统要使用u盘，要mount /dev/sda1 这个设备,映射到某一个目录，比如

```
mount /dev/sda1 /home/cainiao/upan
```

然后对这个目录的读写就是对优盘的读写。

不用的时候umount /dev/sda1  相当于close()

### 2.4.4信息维护

这一节我看了半天还是觉得不知所云，不知道作者所说的信息维护，是要维护什么信息。仅仅最后一段说了一点。

可能作者的意思是操作系统要维护一些系统信息并在必要的时候为用户进程提供：比如当前时间（第一段）、系统出错后的内存信息，并且dump到文件、进程信息等。是这个意思吗？

第三段的程序时间线，没有听说过，百度到的唯一接近的命令是time命令，这个命令可以运行一个程序，并显示程序的运行时间，包括用户态时间和内核态时间。但是程序启动后，time命令就结束了。

### 2.4.5通信

进程通信<mark>常用</mark>模型有两个：共享内存和消息传递。之所以说“常用”，是因为还存在其他不常用的通信方式，比如管道通信。

管道通信是一种很古老的进程通信方式，相互通信的进程可以创建匿名管道（存在高速缓存中，比如内存）和命名管道（文件）来传递信息。因为同一时刻，信息的传递只能是单向的（像管道一样，是半双工通信），所以成为管道通信。

全双工通信：信息可以同时双向，比如同时读写。同时发送接受。

半双工：一个时刻时能单向通信。t1时间A发送，B接受。这个过程完了以后，可以B通过管道（或者其他线路）发送，A接收。

单工：总是只能单向通信。一端只能发送，另外一端只能接收。

消息传递可分为两种：

1. 直接通信：发送进程直接把消息发送给接收进程，**挂载到接收进程的消息缓冲队列上**。
2. 间接通信：发送进程先把消息发送给中间实体，接收进程再从中间实体取得消息。这种方式广泛应用于计算机网络中，例如电子邮件系统。

第二种方式比较好理解，也是平时接触最多的。第一种解释如下：

以熟悉的windows为例，可以说就是一个消息驱动的系统，windows提供了进程之间、进程和操作系统之间的消息传送机制，每一个进程都有自己的消息缓冲队列（准确说，每一个进程的GUI窗口有自己的消息队列），里面存放系统进程（或其他用户进程）给本进程发送的消息：比如“创建窗口”，“鼠标点击”等等。这些消息就是一个struct数据结构，里面必然包含一些参数，比如接收消息的窗口标记、鼠标位置等。

其他进程B可以通过查找进程A的窗口句柄（可以认为是每一个窗口在系统中的唯一全局标识符）来找到这个句柄，然后发送消息，进而实现消息的传递。这些都是通过系统调用函数实现。

对于网络消息传递，书中提到了许多函数，不同的编程语言或者操作系统的函数不一样，明白原理就行。守护进程就像一个服务台一样，负责等待连接，或者说监听所有的连接请求，然后把请求交给专门的服务进程（也可能是异步的线程）去处理，布置好这些后，服务进程接着监听。否则如果前面一个用户申请的服务需求如果需要一个小时，这些工作需要守护进程亲自完成的话，系统就会出现阻塞，其他用户的服务申请无法接听，更无法处理。

关于共享内存，需要相互通信的进程同意，取消进程内存不可被外部访问的限制，同时要注意协调进程对共享内存的访问。

Linux系统中，进程通过四个函数实现创建和访问共享内存（大概了解即可）：

1. ftok函数生成键值

每一个共享存储段都有一个对应的键值id和key。系统通过标识符id和key管理共享内存。ftok函数借用Linux文件系统唯一标识符的特征，创建一个唯一key。

2. shmget函数创建共享存储空间并返回一个共享存储标识符

3. shmat函数获取第一个可用共享内存空间的地址，然后就可以根据这个地址，一个进程写入数据，一个读取数据。

下面是一个简单的代码：程序A创建共享内存，并且在其中写入“Hello Dashen”,程序B读取这个字符串并显示。

* 程序A代码

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_PATH "/home/cainiao/文档/shm"
#define SHM_SIZE 128

int main(int argc, char *argv[])
{
    int shmid;
    char *addr;
    key_t key = ftok(SHM_PATH, 0x6666); // 创建共享内存的key，如果存在则直接返回key

    shmid = shmget(key, SHM_SIZE, IPC_CREAT|IPC_EXCL|0666);//创建共享内存，并且返回其标识符，第三个参数是标志，如果不存在则创建
    if (shmid < 0) {
        printf("failed to create share memory\n");
        return -1;
    }
    addr = (char *)shmat(shmid, NULL, 0); //关联共享内存，并返回其地址
    if (addr == (void *)-1) {
        printf("failed to map share memory\n");
        return -1;
    }

    sprintf(addr, "%s", "Hello Dashen\n"); //向共享内存写入数据

    return 0;
}
```

* 程序B

```cpp
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_PATH "/home/cainiao/文档/shm"
#define SHM_SIZE 128

int main(int argc, char *argv[])
{
    int shmid;
    char *addr;
    key_t key = ftok(SHM_PATH, 0x6666);

    char buf[128];

    shmid = shmget(key, SHM_SIZE, IPC_CREAT);
    if (shmid < 0) {
        printf("failed to get share memory\n");
        return -1;
    }

    addr = (char *)shmat(shmid, NULL, 0);
    if (addr == (char *)-1) {
        printf("failed to map share memory\n");
        return -1;
    }

    strcpy(buf, addr);
    printf("%s", buf);

    return 0;
}
```

先运行程序A，然后运行程序B，输出：Hello Dashen

### 2.4.6保护

操作系统应提供系统保护方面的系统调用，开发语言也应提供对这些系统调用的接口。
