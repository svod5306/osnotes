## 1.2计算机系统的组成

计算机系统包括：一个或者多个CPU，若干设备控制器，他们通过总线连接，并且通过总线通信、访问内存。如下图：

![](file://C:\Users\dgt\Documents\osnotes\assets\2022-10-04-23-44-26-image.png?msec=1664952303258)

直观理解，总线就是连接主板上各种设备的电子线路

设备控制器并不在CPU或者主板上，而是在设备上。比如硬盘里面有硬盘控制器，小小的优盘，里面有优盘控制器。

内存控制器曾经在主板的一个叫做“北桥”的芯片上，现在则大多集成在CPU上。

### 1.2.1计算机系统的运行

- 计算机的引导
  
  计算机的引导过程不是太复杂，但是网上很多说法不一致，主要集中在“引导程序”上。有的人把硬盘MBR分区（一种硬盘分区格式）上的0磁盘0柱面1扇区的内容称为引导程序，是不对的。我觉得书上说的对，引导程序就是存放在计算机的EEPROM（通常就是我们所说的BIOS）里面的代码。
  
  以我老旧的计算机知识介绍大概过程如下（基于MBR引导）：
  
  1）计算机通电后，计算机BIOS的“上电自检程序”会自动检查设备是否存在故障，如果故障（比如内存没有插好或者内存芯片坏掉）会以独特节奏的蜂鸣声提示错误，并停止运行。
  
  2）如果自检通过，BIOS里面的引导程序会根据里面的设置，判断启动设备是哪一个（u盘、光盘或者硬盘、甚至是网络卡），如果是硬盘，就自动读取指定的、采用MBR分区的硬盘（一种硬盘分区格式）的0磁盘0柱面1扇区的内容，这里面包含了一系列信息（注意，此时没有文件系统的概念，就是直接读取物理硬盘指定位置的内容），这些信息包含：一段代码、硬盘分区表格等数据，这些信息称为MBR：主引导记录。
  
  3）如果是单一的系统，MBR的代码通常是固定的，这段代码加载到CPU上运行，然后根据硬盘分区表等信息，把硬盘上操作系统的内核镜像数据加载到内存中（内核景象就是内核程序的二进制指令代码），并设置指令寄存器指向内存中内核的代码，开始运行内核。
  
  4）如果一台机器上有双系统甚至多系统（比如既有windows，又有linux），各个系统通常放在不同的硬盘分区，这时候，MBR里面的代码通常是一个称为“bootloader”的程序代码，bootloader根据配置，提示用户选择某个分区上的操作系统内核。
  
  5）内核启动后，一个基本完整的操作系统开始常驻内存运行，这时候可能会接着运行一些系统程序，这些程序或在前台提供用户交互服务，或者没有界面，在后台默默无闻的提供各种服务。
  
  6）所有这些完成以后，系统开始等待事件发生（比如用户操作、远程的浏览器访问本机的WEB服务等）
  
  事件发生后，通常以中断的方式来通知操作系统：注意了，暂时停下你现在的工作，有新情况需要你处理。这种中断有“硬中断”和"软中断"
  
  - 硬中断：顾名思义就是硬件产生的中断，也就是电信号产生的中断，比如按下键盘，网卡传输信号,除法出错等，这些都会发生电信号引起的硬中断，可以看出，硬中断有CPU内部产生的，也有外部设备发送给CPU的。
  
  - 软中断：就是软件产生的中断。比如我们汇编程序里面int命令产生的中断。我们C语言里面cin<<a也会引起中断，cin的执行会引起“系统调用”，也就是调用操作系统内核的功能，引起中断，让系统等待键盘的输入（内核的这个功能最终还是通过int实现，所以执行系统调用也是触发中断）。
  
  CPU接收到中断信号后，就会停止当前工作，根据中断类型，调用合适的中断服务程序。

- 对于硬中断，CPU还会暂时屏蔽这个中断（称为中断禁止，此时如果再有相同的中断则不再响应，类似于你买了两个外卖，当第一个外卖员给你打电话的时候，此时第二个外卖员无法打通你的电话），叫做中断丢失。

- 对于软中断，Linux的处理方式是这样的：中断处理分为两个步骤：上半部和下半部。上半部在中断禁止模式下运行，处理硬件紧密相关或者时间要求紧迫的工作，然后下半部处理尚未完成的工作，通常是以内核线程（这个概念以后再说，可以理解为操作系统内核调用中断处理程序的部分代码）的方式运行。
  
  举个例子：比如说前面取外卖的例子，上半部就是你接听电话，告诉配送员你已经知道了，其他事儿见面再说，然后电话就可以挂断了；下半部才是取外卖的动作，以及见面后商量发票处理的动作。这样，第一个配送员不会占用你太多时间，当第二个配送员过来时，照样能正常打通你的电话。

- CPU为什么能处理中断
  
  我们知道，中断信号发送给CPU，貌似不需要操作系统介入，CPU就能调用中断处理程序去处理中断，想一想太神奇了，中断处理有的很复杂，甚至分为上下两部走，CPU如何做到这些？
  
  上面的想法有一部分正确，一部分错误。CPU在设计的时候，只会查找内存特定位置的中断向量表，然后根据中断向量表中的中断服务程序地址，设置指令寄存器指向该地址存放的代码，然后执行相应的的代码。而复杂的中断处理代码呢？则是操作系统内核、甚至包括设备的驱动程序实现的。具体过程如下：
  
  - 当BIOS引导系统的时候，会在内存特定位置产生一个中断向量表，当然，这个中断向量表对应的中断服务的处理代码很简单
  
  - 内核启动后，内核会根据情况，修改这个中断向量表，将中断服务程序的地址修改为其他更为复杂的处理代码的地址，或者是操作系统内核的，或者是驱动程序实现的，相当于劫持了中断向量的处理。
    
    这也是为什么在没有操作系统的时候，或者操作系统内核没有启动的时候，计算机也可以响应中断（比如键盘输入），当系统跑起来以后，中断的处理更强大的原因（可以开启线程处理中断）。很多单片机没有操作系统，采用汇编语言开发程序，一样能响应中断，就是硬件里面固话的有简单的中断处理服务程序，当然，开发者也可以写自己的中断处理程序。
  
  猜测一下，假如CPU正在运行程序A（书上经常用进程、线程、任务等名词，还没有学到，暂时就用程序这个名字，更直观），这时候CPU的寄存器、内部缓存一定是和程序A相关的数据，如果CPU转向执行中断处理程序B，那么寄存器、内部缓存的数据势必会替换为与程序B相关的。接着，当中断处理程序B执行完了，CPU再执行程序A，该怎么办呢？CPU怎么知道程序A的地址？另外程序A从头开始执行？还是接着上次没有执行的下一条指令执行？如果从头执行，显然太浪费时间，如果接着执行程序A的下一条指令，这时候，怎么知道程序A下一条指令的内存地址？怎么知道上次执行时候的中间运行结果和其他数据？
  
  显然，我们需要一个方法来在执行程序B之前，保存程序A的现场（就是寄存器、缓存这时候的内容），并且在B执行完之后，在CPU中恢复A的现场。从我们自己思考的角度去分析，这个方法至少应该包含两个数据结构：
  
  1）第一个是一个栈结构，栈顶元素是上一个被中断的程序在内存的地址，执行B之前，A的地址压栈并处于栈顶，开始执行B，B执行完毕，这时候栈顶元素就是A的地址，CPU就很容易获取A程序的内存地址，A再出栈。
  
  2）第二个数据结构应该保存程序A在被干掉前的状态信息（上下文），比如寄存器数据、下一条待执行指令的地址、等等。这个数据结构有个名词：PCB（进程控制块）,后面详细解释。PCB保存在<mark>操作系统所在的内存空间中</mark>。
  
  实际上操作系统设计者基本上也是这么做的。只不过考虑的因素更多更复杂一些。
  
  这里有个词：<mark>操作系统所在内存空间</mark>。操作系统为了保护自己不受破坏，整体上把系统内存划分为两个部分，内核内存（运行操作系统内核和系统关键程序），用户内存（运行用户自己编写的程序）。内核内存不允许用户直接访问，以免系统出现问题。

### 1.2.2存储结构

基本上就几种：

1）RAM（随机存储器）：就是我们常说的内存，开机通电才会保存数据，关机数据就丢失。注意，普通人常说的手机内存是错误的说法。他们说的手机内存其实就是手机里面的固态存储器，类似于电脑的硬盘的作用。

2）ROM（只读存储器的简写）：一次写入后就不能更改，只能读取，比如常见的光盘，还有一些里面的一些只读存储芯片。

3）EEPROM：（可擦除可编程只读存储器），可以修改内容，但是不能随意或者经常修改。比如我们计算机上的BIOS芯片，一般不修改，但是有时候如果厂商发现BIOS的程序有BUG，也会提供专门的工具和BIOS代码文件，让我们可以更新BIOS内容

上面的存储器大多位于计算机系统内部，以芯片的形式存在，一般叫做内部存储器，硬盘、光盘、优盘等通过外部设备接口连接的存储器，称为外部存储器。

题外话：这么说，手机里面的存储器被称作内存也是合理的，所以为了和RAM区别，手机内部的RAM被人称为运存（运行内存）

其实还有其他类型的存储器，比如寄存器、CPU内部的1级2级高速缓存等。不同的存储器存取数据的速度不一样，而且之间具有层次关系，书上P11页图1-4显示了这个关系

### 1.2.3I/O结构

前面说过，CPU和各种IO设备通过总线连接并且通信（一般是这样子，也有特殊，后面总结的DMA就是特例），每个IO设备都有自己的控制芯片和电路（整体称为控制器，包含一个功能单一、简单的微型CPU），同时基本上每一个IO设备也有自己的缓冲内存（缓冲区）和特定用途的寄存器（比如显卡有自己的显存，而且大部分显卡的显存容量甚至比计算机内存的容量都大，键盘也有自己的缓冲内存）。

操作系统通过设备驱动程序和设备控制器通信，因此，很多设备，尤其是采用新技术的设备，都有自己的驱动程序，否则操作系统无法有效利用设备，甚至无法使用这个设备。

驱动程序扮演 着中断服务程序的角色，以键盘输入为例：

按下键盘后，键盘控制器会将按下的键盘数据送到键盘设备的缓冲区里面，然后向CPU发送中断，CPU查找中断向量表，根据表格记录的中断处理程序（通常由驱动程序提供）处理这个数据输入操作，处理完后，控制权交给操作系统，接着处理其他程序的执行。大概过程如此，具体细节按照上面说的两部法，可能还会暂时禁止这个中断。

什么是DMA：

DMA是直接内存访问的英文缩写。目的是加快IO设备向内存传送数据的速度。

举例来说，如果不采用DMA，当用户程序要访问硬盘数据的时候，会发送一个软中断指令（因为是调用系统功能，此处具体说就是调用系统访问硬盘数据的功能，所以后面的章节称为”**<mark>系统调用</mark>**“），具体的执行就是CPU调用中断处理程序（可能是驱动程序，注意，既然是程序就要在CPU运行）去和硬盘控制器通信（IO请求），控制器读取数据后放在自己的缓存中，读取完成后，硬盘控制器再发送一个中断请求（这时候是硬中断），通知CPU自己已经完成了操作，再次调用设备驱动程序将缓存数据读出，并存放在内存中（参考P12页图1-5）。这些操作是在CPU运行，中断处理程序代码中实现的。如果数据量少的低速设备还可以接受，如果数据量大的高速设备，比如硬盘，它的缓冲区容量有限，读取大量数据的时候，就要一次次的发送中断请求CPU处理。效率很低。

如果有了DMA，中断服务程序（驱动程序）直接向DMA控制器发送指令，告诉它要读取哪一个设备，读取数据长度多少，等等信息，然后CPU开始干其他工作，DMA控制器和硬盘控制器配合读取数据后，直接将数据存放在内存中（无需CPU参与处理），整体完毕后发中断通知CPU。具体更详细的细节，查阅很多资料，都说的不清楚。大概了解即可。

优点：传送数据时候无需CPU频繁干预，也减少中断次数，CPU可以有更多的时间参与其他计算。
