前面2.4节总结了一些共享内存通信的东西。

共享内存的知识点：无非两个方面，一是如何创建共享内存，需要进程间通过同意取消“进程内部内存不可被外部进程访问”这一限制。这个限制在linux系统编程中，通过ftok,shmget,shmat三个函数组合实现。

二是进程间如何协调访问共享内存。

* 其实，感觉整本书都是在讨论资源分配的策略，资源访问的粗略。脱脱的就是策略逻辑+一些数据结构+一些算法

书上以生产者和消费者进程通信为例，讲了有界缓冲区的访问。缓冲区这个概念经常出现，什么键盘缓冲区，硬盘缓冲区，共享内存中的缓冲区等等，感觉这个概念是从生产者、消费者角度的产生的概念，因为缓冲区有不少类型，有的缓冲区是硬件内部的存储器，是不可以被操作系统分配的，有的是内存中操作系统分配的。而共享内存则是从内存是否只能被一个进程访问而产生的概念，访问共享内存的额进程可能不是严格的生产者和消费者。不知道理解对不对。<mark>可以问下老师</mark>。

### 3.4.2消息传递系统

消息是进程间通过“通信链路”通信的方式，进程间逻辑链路的实现有三种：

![](../../assets/2022-10-13-17-06-01-image.png)

1）命名（或许可以理解为直接通信，因为通信双方必须要清楚对方的name，不知道这么理解对不对）

这一节的翻译，尤其是第二段的翻译怪怪的。

什么是“命名”？中文翻译没有体现，英文版可能会有提示：Under direct communication, each process that wants to communicate must explicitly name the recipient or sender of the communication.

这句话表明，直接通信的双方，必须接受方或者发送方的name，为什么这样子？难道通信不是必然要知道对方吗？其实不是，还有匿名通信于此对应。

这种通信需要两个进程知道对方身份;

每个通信链路只有两个进程，一个发送，一个接收

每一对进程之间只有一个链路

这种方案体现了寻址的对称性，所谓对称性，发送和接收进程都必须指定对方。

上面的方案有一个变种，称为采用非对称寻址的通信，就是发送者指定接收者，而接受者不必指定发送者。

至于作者煞有介事的send receive函数的各种形式，找不到具体的C++编程代码。

下面的内容读起来拗口，意思晦涩：

![](../../assets/2022-10-13-20-16-15-image.png)

我的个人理解如下，不知道和老师说的一样不一样：

这两种消息通信方式因为必须确切的指定通信双方的标识（比如可能是PID），因此灵活性比较差，比如一旦进程重新运行，进程标识符就会改变，采用这种硬编码（硬性设置）的方式就会遇到问题，导致进程之间不能通信。

而间接通信则解决了这个问题，通信双方不必互相标明名称，生产者把消息发给“邮箱”，消费者把消息从邮箱取出。这时候，只要邮箱标识固定就行。

这种通信具有如下特点：

1）两个进程共享同一个邮箱才可通信

2）一个链路可以与两个或更多进程相关联（书中假设的P1，P2，P3共享一个邮箱A的例子，我认为就是对这种情况的进一步分析）

3）两个进程间可以有多个不同的链路，每个链路对应于一个邮箱，这样子就会存在多个邮箱。
