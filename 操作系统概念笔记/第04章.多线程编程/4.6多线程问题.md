### 4.6.1系统调用fork和exec

作者讲述了如果线程内fork，系统是否为产生的新进程复制所有线程的问题，以及fork后如果exec的时机不同，是否有必要复制线程的问题

### 4.6.2信号问题

Unix，Linux下叫做信号(Signal)。Windows称为消息。
Linux下可以通过kill、raise、alarm、pause这些信号处理系统调用来实现。

信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。
信号是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。
信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
注意，信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据

进程内部异常或者出错等原因，产生的信号是同步信号，这时候信号会发送到这个出错的进程。

异步信号是进程以外的事件产生的，啥时候会产生，不确定，因为发送信号的进程和接收信号的进程是异步运行的。

信号处理程序负责对接收的信号做出适当的处理。可以是缺省的信号处理程序（系统内核驱动、实现），也可以是用户定义的信号处理程序。从这一点上来看，有些像windows对消息的处理。比如点击windows窗口右上角，默认处理是关闭窗口，但是实际上我们可以改写对WM_CLOSE消息的处理，实现其他操作。

单线程程序，信号发给进程即可

多线程程序，信号传递分为四种情况：

![](../../assets/2022-10-19-12-34-54-image.png)

具体怎么传递还取决于信号的类型，书上有解释。

Windows的APC（异步过程调用）模拟信号支持，并且APC直接把信号传递给线程，而不是进程。

 至于windows APC和 windows窗口程序编程时候的消息处理之间的关系，网上找不到资料，有必要可以问老师。书上也没有对APC举例，可能怕说的越多，引申的越多，越麻烦。先让大家有个基本印象。

### 4.6.3线程撤销

书上对于线程的撤销，有两种情况：

![](../../assets/2022-10-19-15-54-14-image.png)

这点有疑问，一个线程可以“立即终止”别的线程吗？如果这样子，目标进程正在打开的文件、正在共写的内存怎么办？如果资源已经被目标线程加锁了，其他线程无法使用怎么办？

pthread_cancel(tid)可以给线程发送终止信号，这个函数返回值=0,表示终止成功，否则终止失败。

书上说的三种撤销模式，其实对应的是两个函数：

```
设置本线程对Cancel信号的反应
int pthread_setcancelstate(int state, int *oldstate);
state有两种值：PTHREAD_CANCEL_ENABLE（缺省）和PTHREAD_CANCEL_DISABLE
分别表示收到信号后设为CANCLED状态和忽略CANCEL信号继续运行；old_state如果不为NULL则存入原来的Cancel状态以便恢复。

设置本线程取消动作的执行时机
int pthread_setcanceltype(int type, int *oldtype);
type由两种取值：PTHREAD_CANCEL_DEFFERED和PTHREAD_CANCEL_ASYCHRONOUS
仅当Cancel状态为Enable时有效，分别表示收到信号后继续运行至下一个取消点再退出和立即执行取消动作（退出）；oldtype如果不为NULL则存入运来的取消动作类型值。
```

 举一个简单的例子：

```cpp
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
void *thread_Fun(void *arg)
{
    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE,NULL);
    printf("新建线程开始执行\n");
    sleep(100);
    return 0;
}

int main()
{
    pthread_t myThread;
    void *mess;
    int value;
    int res;
    //创建 myThread 线程
    res = pthread_create(&myThread, NULL, thread_Fun, NULL);
    if (res != 0)
    {
        printf("线程创建失败\n");
        return 0;
    }
    sleep(1);
    //向 myThread 线程发送 Cancel 信号
    res = pthread_cancel(myThread);
    if (res != 0)
    {
        printf("终止 myThread 线程失败\n");
        return 0;
    }
    //获取已终止线程的返回值
    res = pthread_join(myThread, &mess);
    if (res != 0)
    {
        printf("等待线程失败\n");
        return 0;
    }
    //如果线程被强制终止，其返回值为 PTHREAD_CANCELED
    if (mess == PTHREAD_CANCELED)
    {
        printf("myThread 线程被强制终止\n");
    }
    else
    {
        printf("error\n");
    }
    return 0;
}
```

上面的代码编译需要加上 -lpthread参数。

如果线程函数里面注释掉：pthread_setcancelstate(PTHREAD_CANCEL_DISABLE,NULL); 则正常情况下，程序运行一秒后就会终止这个线程。但是现在设置了线程关闭了取消信号的反应，则线程就不会被终止，一直等待100秒结束运行。

所谓的撤销点，就是告诉线程，运行到这个语句才可以退出。上面的代码我们对thread_Fun函数做一下修改，设置一个撤销点：

```cpp
void *thread_Fun(void *arg)
{
    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE,NULL);    
    printf("新建线程开始执行\n");
    sleep(10);
    printf("现在可以终止线程了!");
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL);
    pthread_testcancel();    
    printf("这是撤销点以后的语句，不会被执行");
    return 0;
}
```

pthread_testcancel()需要配合pthread_setcancelstate才可以正常起作用，上面的代码如果屏蔽掉两行pthread_setcancelstate，则会在printf("现在可以终止线程了!");之前就被终止。

但是如果把sleep()换成一个for循环，当for循环执行时间比较短，撤销点貌似无效，最后一个printf语句仍然会执行，加入for循环比较耗时，则撤销点以后的语句不会执行。

不知道原因。不知道pthread文档不推荐异步撤销，有么有因为这些奇怪问题的原因。

### 4.6.4线程本地存储

又叫线程局部存储，其实就是线程私有的全局变量。

c语言中这么实现：__thread int g = 0;

这样子，每一个线程就有一个私有的全局变量 int g.

### 4.6.5调度程序激活

前面总结过，用户线程对内核来说是看不到的，内核以进程为调度对象，进程内部有什么操作，或者线程，内核不知道，所以用户线程不能利用多处理器系统的优势，线程只能轮番在所属进程的CPU时间片内运行。

当操作系统要支持多线程的时候，内核就需要知道进程有多少个线程，如何切换线程，如何为多线程分配多个CPU，要做到这些，其实就相当于把线程当作进程看待了，需要一个类似PCB的数据结构来管理线程，这个数据结构就是LWP（想起来1.3节我们第一个多线程程序运行的时候，debug out的输出吗？），称为轻量级线程。

前面4.3说过：线程控制块TCB，貌似和LWP是一种东西，这二者是什么关系呢？经过多方查资料，我个人得出的结果如下：二者只是像，作用类似，都是控制管理线程的数据结构，但是没有什么关系。TCB是windows系统多线程管理的方案，而LWP是Linux多线程管理的方案（这个观点有待问老师确认），很多说法是：

Linux并没有真正意义上的线程，只有进程，Linux用轻量级的进程模拟线程，为了实现这个，Linux把线程代码包装成进程的样子，但是因为这个进程的上下文简单，所以称为轻量级线程。

#### 关于“调度器激活”

感觉书上说的比较混乱：一会儿给程序发送回调执行回调函数，一会儿给线程库发送回调，执行线程库（如下图）。

![](../../assets/2022-10-22-11-34-31-image.png)

下面谈的的我的理解，不知道对不对，可以问老师求证。网上的很多文章我看了基本上也是照抄书上内容，说的语焉不详，不知道作者是否真的深究了还是他们明白但是没说清楚。

我对调度器激活方案的理解：系统内核提供LWP这个数据结构（书中也称为虚拟处理器，不明白为什么，大概是因为转成了进程就可以理论上分配CPU执行啦？看了英文原版，作者翻译的好像也没啥问题，但是意思表达的不好：）来管理我们的线程，但是请注意，分配多少个LWP是由内核决定（大概也是经验估计，多对多模型也没说具体细节），但是把LWP分配给哪一个线程，内核是不知道的，因为内核看不到进程内部的线程（大家常说的线程对内核透明），书上说是“应用程序可以调度线程到任何一个可用虚拟处理器”，那也就是应用程序自己给线程分配LWP（尽管我们的程序代码里面并没有这样的代码，但是根据书上的信息，可以猜测编译、链接后的程序具备这个能力，尽管实现细节不清楚，甚至可能是在编程语言提供的线程库的协作下实现的，PS：后知后觉的总结，应该是下面所说的回调函数负责LWP的分配）。

这时候存在一个问题，假如系统提供了m个LWP，但是程序有N个线程，而且N>m，如果一个拥有LWP的线程这时候因为某种操作（比如常见的IO）要阻塞了，阻塞的LWP进程这时候就要被放到阻塞队列，这时候就会释放出它占用的LWP，系统不会为这个线程一直保留LWP，毕竟系统资源是要精打细算的。内核怎么把这个释放出了一个LWP的事件怎么告诉程序（让程序再分配一个进程到这个LWP）是一个问题。Linux采用了一种称为“回调”的处理方法。

简单说一下什么是回调，正常情况下，我们的函数，别人提供的大多数函数，都是我们自己主动调用，回调函数的一种形态：是在程序运行中，被系统主动调用的函数。通常是我们调用系统的API，但是系统调用我们的函数，这个函数就是回调函数，回调函数通常会以参数类型为“函数指针”的形式传递给系统的API（本质上，回调函数就是给别人以函数指针形式调用的函数），所以内核知道调用我们的哪一个函数。

根据书上的内容，既然是探讨内核和线程库的通信，我认为回调函数是在线程库中独立实现的，并没有像我在上面猜测的那样，被静态链接到了用户程序。因此，所谓的通知应用线程库，应该是通知应用程序更合适，函数库不是进程，没办法通知，但是可以通知程序，程序再动态加载线程库的回调处理函数到自己的代码空间运行。

所以下面的讨论，我基本上会将线程库替换成“程序”。

接着说，当一个线程即将阻塞的时候，内核做了两件事：

1）获取正在阻塞的线程的标识，并将这个线程的标识发给回调函数

2）分配一个新的LWP给程序，程序把这个LWP分配给回调函数，回调函数有了LWP，就可以像线程包装成进程那样，运行回调函数的处理程序。

回调函数运行起来后，它做了下面几件事（做下面事情的时候，要利用到内核传递过来的那个线程标识）：

1）把阻塞的线程所用的LWP分配给其他线程运行。

2）保持被阻塞线程的状态。

这时候，被阻塞的线程等待IO完成，其他线程被继续分配LWP继续运行。

至于回调函数本身占用的LWP会不会被释放掉，书上没说，我想是会被释放掉的，因为既然每次都分配一个LWP，那么上次的使用的LWP没有理由占着不释放，而且内核那么抠门，地主家里也不富裕。

当被阻塞线程的IO完成，线程具备继续运行的条件的时候。内核会像上次那样：

1）回调程序的回调处理函数，给它分配一个LWP让它运行。

2）给程序分配一个LWP，这个LWP可能是新生成的，也可能是抢占优先级低的线程的。

然后回调函数分配这个LWP给被阻塞的线程。并取消阻塞状态。

**上是查找很多资料，自己分析后的理解，可能不正确，可以向老师求证**
