## 1.6进程管理

前面说了：进程是运行的程序，一个程序可能有多个进程。比如你打开两个word字处理软件，chrome浏览器打开多个标签。都会产生一个程序多个进程。

一个计算机系统上会有多个进程，包含操作系统进程和用户程序产生的进程。当计算机只有一个CPU的时候，所有进程轮换在CPU上运行。多处理器系统才会存在同时运行的情况。

每一个进程都对应一个叫做PCB的数据结构（进程控制块），由操作系统维护，包含进程运行的信息（内存的数据信息，寄存器信息等），这些信息在进程被重新调度、运行的时候很有用。可以脑补推测一下，书上说的“用来保存下一条指令地址的PC（程序计数器）”，其实保存的可能是CPU指令指针寄存器IP的数据。

前面讲过，一个进程可以由多个线程，实际上，操作系统和CPU是不知道程序里面有什么函数，干了什么的，只要不申请中断和系统调用，或者执行危险的特权指令，进程对于操作系统来说就像透明人一样。

另外，操作系统是以进程为单位分配计算机资源的，也就是说，对于CPU时间片的分配也是以进程为单位对象，这样子就带来了一个问题：

以网络视频播放为例：

我们实现一个多线程程序的目的通常是为了多个线程能协调处理某一件工作，比如一个视频播放器，需要一边缓冲一边播放，如果缓冲代码-->播放代码-->缓冲代码...，就会播放起来一会儿一停顿。这时候需要至少两个线程，一个只管缓存视频数据，一个只管播放，网速快的情况下，缓存速度超过播放速度，视频播放不会卡顿。

问题1：CPU运行时间的分配是以进程为单位的，如果操作系统不支持多线程，也就是说，无论你的程序设计了多少个线程，实际上，当线程被运行的时候，线程使用的还是进程所占的时间片，只不过变成了：这个时间片执行进程的缓冲线程代码，下次执行播放线程代码，这在事实上变成了这些子线程竞争使用父进程的CPU资源，并没有起到我们想要的效果。

问题2：由于线程是在进程的资源内运行，操作系统看不到我们的线程，或者说把线程的运行看作进程的运行，那么当一个子线程因为IO需要等待的时候，整个程序进程都会停止运行，阻塞我们其他线程的运行。这也与我们的设计目标不符。我们希望各个线程各自独立运行，互补影响。

所以有必要采取一种方法让各个线程能像进程一样，独自运行，抢占公共的CPU时间片资源。Linux采用的是LWP方法，就是把一个个线程包装成一个个的进程，不过稍微简化了，称为轻量级进程（LWP），这里只是先说一下，后面再稍微详细学习。

单个CPU系统对于多个进程的支持采用多路复用实现。多路复用这个概念在各个领域都会出现，比如通信领域，它是一个充分利用硬件资源的概念，不是具体的技术实现细节或者标准。比如通信电缆的多路复用，可取方法之一是一个线路同时发送不同频率电信号，就能实现同时多个频率的数据通信。CPU的多路复用，其实就是通过时间片的划分，在宏观上表现出多个程序同时运行的样子。

操作系统负责管理进程的以下活动：

1. 在CPU上调度进程和线程

2. 创建和删除用户进程和线程

3. 挂起和重启进程。所谓挂起进程，就是有些进程可能因为某种原因，被系统暂时清除出内存，停止运行，并把状态保存在磁盘系统（比如虚拟内存）上。
